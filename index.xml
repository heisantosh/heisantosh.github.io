<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Delay Line Memory</title><link>https://heisantosh.github.io/</link><description>Recent content on Delay Line Memory</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 18 Jan 2026 10:00:00 +0530</lastBuildDate><atom:link href="https://heisantosh.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding Go Context</title><link>https://heisantosh.github.io/blog/2026/01/18/understanding-go-context/</link><pubDate>Sun, 18 Jan 2026 10:00:00 +0530</pubDate><guid>https://heisantosh.github.io/blog/2026/01/18/understanding-go-context/</guid><description>&lt;blockquote&gt;
&lt;p&gt;AI generated to act as place holder for my blog post!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;code&gt;context&lt;/code&gt; package in Go is one of those features that seems simple at first but reveals its depth as you work with it more. It&amp;rsquo;s become essential for writing robust, concurrent Go programs.&lt;/p&gt;
&lt;h2 id="what-problem-does-context-solve"&gt;What Problem Does Context Solve?&lt;/h2&gt;
&lt;p&gt;When you&amp;rsquo;re building services, you often need to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Cancel operations&lt;/strong&gt; when a request times out&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pass request-scoped values&lt;/strong&gt; through your call chain&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set deadlines&lt;/strong&gt; for operations&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Before context, developers passed around cancellation channels and deadline values manually. Context standardizes this.&lt;/p&gt;</description></item><item><title>Why I Prefer CLI Tools</title><link>https://heisantosh.github.io/blog/2026/01/15/why-i-prefer-cli-tools/</link><pubDate>Thu, 15 Jan 2026 14:30:00 +0530</pubDate><guid>https://heisantosh.github.io/blog/2026/01/15/why-i-prefer-cli-tools/</guid><description>&lt;blockquote&gt;
&lt;p&gt;AI generated to act as place holder for my blog post!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;After years of using various development tools, I&amp;rsquo;ve found myself gravitating more and more toward command-line interfaces. Here&amp;rsquo;s why.&lt;/p&gt;
&lt;h2 id="composability"&gt;Composability&lt;/h2&gt;
&lt;p&gt;The Unix philosophy of small tools that do one thing well remains powerful. I can pipe &lt;code&gt;grep&lt;/code&gt; into &lt;code&gt;sort&lt;/code&gt; into &lt;code&gt;uniq&lt;/code&gt; into &lt;code&gt;wc&lt;/code&gt; and get exactly what I need. Try doing that with a GUI.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git log --oneline &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;#34;fix&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; wc -l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This tells me how many commits contain &amp;ldquo;fix&amp;rdquo; in their message. Simple, fast, and I didn&amp;rsquo;t need to click through any menus.&lt;/p&gt;</description></item><item><title>Building Better Abstractions</title><link>https://heisantosh.github.io/blog/2026/01/10/building-better-abstractions/</link><pubDate>Sat, 10 Jan 2026 09:15:00 +0530</pubDate><guid>https://heisantosh.github.io/blog/2026/01/10/building-better-abstractions/</guid><description>&lt;blockquote&gt;
&lt;p&gt;AI generated to act as place holder for my blog post!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Good abstractions are invisible. Bad abstractions are constant friction. After building and maintaining software for a while, I&amp;rsquo;ve developed some intuitions about what makes the difference.&lt;/p&gt;
&lt;h2 id="the-leaky-abstraction-problem"&gt;The Leaky Abstraction Problem&lt;/h2&gt;
&lt;p&gt;Joel Spolsky coined &amp;ldquo;The Law of Leaky Abstractions&amp;rdquo; - all non-trivial abstractions leak. But some leak less than others. The goal isn&amp;rsquo;t perfection; it&amp;rsquo;s minimizing how often users need to understand the underlying implementation.&lt;/p&gt;</description></item><item><title>about</title><link>https://heisantosh.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heisantosh.github.io/about/</guid><description>&lt;p&gt;Hi, I&amp;rsquo;m &lt;strong&gt;Santosh Heigrujam&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Currently, I&amp;rsquo;m working on cloud infrastructure tooling at Microsoft Azure. In one of my previous roles, I work on the backend powering &lt;code&gt;npm&lt;/code&gt; at GitHub, and improving developer experiences on the website.&lt;/p&gt;
&lt;p&gt;Recently, I have been practing using Rust in distributed systems.&lt;/p&gt;
&lt;p&gt;You can find me on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/heisantosh"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://linkedin.com/in/santosh-heigrujam"&gt;LinkedIn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="santosh.hei@gmail.com"&gt;santosh.hei@gmail.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>